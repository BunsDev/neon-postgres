// Page service presented by pageservers, for computes.
//
// Request metadata:
// - authorization: JWT token ("Bearer <token>"), if auth is enabled
// - neon-tenant-id: tenant ID ("7c4a1f9e3bd6470c8f3e21a65bd2e980")
// - neon-shard-id: shard ID, as <number><count> in hex ("0b10" = shard 11 of 16)
// - neon-timeline-id: timeline ID ("f08c4e9a2d5f76b1e3a7c2d8910f4b3e")
// - neon-priority: used e.g. for metrics ("normal" or "low"), prefetches would be "low"
//
// TODO:
// - Backpressure? Rate limiting?
// - Health checks?
// - Tracing? OpenTelemetry?
// - Compression?
//

syntax = "proto3";
package page_service;

service PageService {
  // Returns the total size of a database, as # of bytes.
  rpc DbSize (DbSizeRequest) returns (DbSizeResponse);

  // Returns whether a relation exists.
  rpc RelExists(RelExistsRequest) returns (RelExistsResponse);

  // Returns the size of a relation, as # of blocks.
  rpc RelSize (RelSizeRequest) returns (RelSizeResponse);

  // Fetches a base backup.
  rpc GetBaseBackup (GetBaseBackupRequest) returns (stream GetBaseBackupResponseChunk);

  // Fetches a page.
  // TODO: remove this and use GetPages. Kept for benchmarks.
  rpc GetPage (GetPageRequest) returns (GetPageResponse);

  // Fetches pages.
  //
  // This is implemented as a bidirectional streaming RPC for performance. Unary
  // requests incur costs for e.g. HTTP/2 stream setup, header parsing,
  // authentication, and so on -- with streaming, we only pay these costs during
  // the initial stream setup. This ~doubles throughput in benchmarks.
  //
  // NB: a status response (e.g. for errors) will terminate the stream. The
  // stream may be shared by e.g. multiple Postgres backends, so we should avoid
  // this. Most errors are instead propagated in the GetPageResponse.
  rpc GetPages (stream GetPageRequest) returns (stream GetPageResponse);

  // Fetches an SLRU segment.
  rpc GetSlruSegment (GetSlruSegmentRequest) returns (GetSlruSegmentResponse);
}

message RequestCommon {
  uint64 request_lsn = 1;
  uint64 not_modified_since_lsn = 2;
}

message RelTag {
    uint32 spc_oid = 1;
    uint32 db_oid = 2;
    uint32 rel_number = 3;
    uint32 fork_number = 4;
}

message RelExistsRequest {
  RequestCommon common = 1;
  RelTag rel = 2;
}

message RelExistsResponse {
  bool exists = 1;
}

message RelSizeRequest {
  RequestCommon common = 1;
  RelTag rel = 2;
}

message RelSizeResponse {
  uint32 num_blocks = 1;
}

message GetPageRequest {
  // A request ID. Will be included in the response. Should be unique for
  // in-flight requests on the stream.
  uint64 id = 1;
  RequestCommon common = 2;
  RelTag rel = 3;
  uint32 block_number = 4;
}

// TODO: should this include page metadata, like reltag, LSN, and block number?
message GetPageResponse {
  // The original request's ID.
  uint64 id = 1;
  // The 8KB page image.
  bytes page_image = 2;
}

message DbSizeRequest {
  RequestCommon common = 1;
  uint32 db_oid = 2;
}

message DbSizeResponse {
  uint64 num_bytes = 1;
}

message GetBaseBackupRequest {
  RequestCommon common = 1;
  bool replica = 2;
}

message GetBaseBackupResponseChunk {
  bytes chunk = 1;
}

message GetSlruSegmentRequest {
  RequestCommon common = 1;
  uint32 kind = 2;
  uint32 segno = 3;
}

message GetSlruSegmentResponse {
  bytes segment = 1;
}