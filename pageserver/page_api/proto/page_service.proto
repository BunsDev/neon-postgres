// Page service presented by pageservers, for computes.
//
// Request metadata:
// - authorization: JWT token ("Bearer <token>"), if auth is enabled
// - neon-tenant-id: tenant ID ("7c4a1f9e3bd6470c8f3e21a65bd2e980")
// - neon-shard-id: shard ID, as <number><count> in hex ("0b10" = shard 11 of 16)
// - neon-timeline-id: timeline ID ("f08c4e9a2d5f76b1e3a7c2d8910f4b3e")
//
// TODO: write implementation guidance on
// - Health checks
// - Tracing, OpenTelemetry
// - Compression

syntax = "proto3";
package page_service;

service PageService {
  // Returns the total size of a database, as # of bytes.
  rpc DbSize (DbSizeRequest) returns (DbSizeResponse);

  // Fetches a base backup.
  rpc GetBaseBackup (GetBaseBackupRequest) returns (stream GetBaseBackupResponseChunk);

  // Fetches a page.
  // TODO: remove this and use GetPages. Kept for benchmarks.
  rpc GetPage (GetPageRequest) returns (GetPageResponse);

  // Fetches pages.
  //
  // This is implemented as a bidirectional streaming RPC for performance. Unary
  // requests incur costs for e.g. HTTP/2 stream setup, header parsing,
  // authentication, and so on -- with streaming, we only pay these costs during
  // the initial stream setup. This ~doubles throughput in benchmarks.
  //
  // NB: a status response (e.g. for errors) will terminate the stream. The
  // stream may be shared by e.g. multiple Postgres backends, so we should avoid
  // this. Most errors are instead propagated in the GetPageResponse.
  rpc GetPages (stream GetPageRequestBatch) returns (stream GetPageResponse);

  // Fetches an SLRU segment.
  rpc GetSlruSegment (GetSlruSegmentRequest) returns (GetSlruSegmentResponse);

  // Returns whether a relation exists.
  rpc RelExists(RelExistsRequest) returns (RelExistsResponse);

  // Returns the size of a relation, as # of blocks.
  rpc RelSize (RelSizeRequest) returns (RelSizeResponse);

}

message RequestCommon {
  uint64 request_lsn = 1;
  uint64 not_modified_since_lsn = 2;
}

message RelTag {
    uint32 spc_oid = 1;
    uint32 db_oid = 2;
    uint32 rel_number = 3;
    uint32 fork_number = 4;
}

message RelExistsRequest {
  RequestCommon common = 1;
  RelTag rel = 2;
}

message RelExistsResponse {
  bool exists = 1;
}

message RelSizeRequest {
  RequestCommon common = 1;
  RelTag rel = 2;
}

message RelSizeResponse {
  uint32 num_blocks = 1;
}

// A single GetPage request.
message GetPageRequest {
  // A request ID. Will be included in the response. Should be unique for
  // in-flight requests on the stream.
  uint64 id = 1;
  RequestCommon common = 2;
  RelTag rel = 3;
  uint32 block_number = 4;
  GetPageClass class = 5;
}

// A GetPageRequest class. Primarily intended for observability, but may also be
// used for prioritization in the future.
enum GetPageClass {
  // Unknown class. For forwards compatibility: used when the client sends a
  // class that the server doesn't know about.
  GET_PAGE_CLASS_UNKNOWN = 0;
  // A normal request. This is the default.
  GET_PAGE_CLASS_NORMAL = 1;
  // A prefetch request.
  GET_PAGE_CLASS_PREFETCH = 2;
}

// A batch of GetPage requests. These will be executed as a single batch by the
// Pageserver, amortizing layer access costs and parallelizing them. This may
// increase the latency of any individual request, but improves the overall
// latency and throughput of the batch as a whole.
//
// Responses will be emitted individually, as soon as they are ready. They may
// be emitted in a different order than the requests.
message GetPageRequestBatch {
  repeated GetPageRequest requests = 1;
}

// A GetPage response. May be emitted out of order.
//
// TODO: should this include page metadata, like reltag, LSN, and block number?
message GetPageResponse {
  // The original request's ID.
  uint64 id = 1;
  // The response status code.
  GetPageStatus status = 2;
  // A string describing the status, if any.
  optional string reason = 3;
  // The 8KB page image. Empty if status != OK.
  bytes page_image = 4;
}

// A GetPageResponse status code. Since we use a bidirectional stream, we don't
// want to send errors as gRPC statuses, since this would terminate the stream.
enum GetPageStatus {
  // Unknown status. For forwards compatibility: used when the server sends a
  // status code that the client doesn't know about.
  GET_PAGE_STATUS_UNKNOWN = 0;
  // The request was successful.
  GET_PAGE_STATUS_OK = 1;
  // The page did not exist. The tenant/timeline/shard has already been
  // validated during stream setup.
  GET_PAGE_STATUS_NOT_FOUND = 2;
  // The request was invalid.
  GET_PAGE_STATUS_INVALID = 3;
  // The client is rate limited. Slow down and retry later.
  // TODO: should we use this?
  GET_PAGE_STATUS_SLOW_DOWN = 4;
}

message DbSizeRequest {
  RequestCommon common = 1;
  uint32 db_oid = 2;
}

message DbSizeResponse {
  uint64 num_bytes = 1;
}

message GetBaseBackupRequest {
  RequestCommon common = 1;
  bool replica = 2;
}

message GetBaseBackupResponseChunk {
  bytes chunk = 1;
}

message GetSlruSegmentRequest {
  RequestCommon common = 1;
  uint32 kind = 2;
  uint32 segno = 3;
}

message GetSlruSegmentResponse {
  bytes segment = 1;
}